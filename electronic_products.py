# -*- coding: utf-8 -*-
"""Electronic Products.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11PTCNyKUZqEwMgljm0ThFmnXb4SlxCtw
"""

pip install pmdarima

#Import all necessary Libraries
import warnings
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import statsmodels.api as sm
from pmdarima import auto_arima
from sklearn import metrics
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller
warnings.filterwarnings("ignore")

#Import the data set
data = pd.read_excel('/content/Quarterly export current prices fisheries  products.xlsx')
data.head()

#Put data set in a data frame
df = pd.read_excel(r'/content/Quarterly export current prices fisheries  products.xlsx', parse_dates = True)

#Explanatory Data Analysis
df["Fisheries"].plot(figsize=(15, 6))
plt.xlabel("Date")
plt.ylabel("Current Price")
plt.title("Current Price of Export Fishery Products")
plt.show()
#Kernel Density Function
plt.figure(1, figsize=(15,6))
plt.subplot(211)
df["Fisheries"].hist()
plt.subplot(212)
df["Fisheries"].plot(kind='kde')
plt.show()

Current_export_price = pd.read_excel('/content/Quarterly export current prices fisheries  products.xlsx', parse_dates=['Date '], index_col='Date ')
Current_export_price.info()

# Extract the "Date" and "Fisheries" columns for seasonal decomposition
data_for_decomposition = Current_export_price[['Fisheries']]

decomposition = sm.tsa.seasonal_decompose(data_for_decomposition)
# Extract the trend and seasonal components
trend = decomposition.trend
seasonal = decomposition.seasonal

# Create a new DataFrame with the trend and seasonal components
Current_export_price_decomposed = pd.concat([trend, seasonal], axis=1)
print(Current_export_price_decomposed.head(10))

# Plot the values of the Current_export_price_decomposed DataFrame
ax = Current_export_price_decomposed.plot(figsize=(12, 6), fontsize=15)
# Specify axis labels
ax.set_xlabel('Date', fontsize=15)
ax.set_ylabel('Current Export Price', fontsize=15)
plt.legend(fontsize=15)
plt.show()

#Import all necessary Libraries
import warnings
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import statsmodels.api as sm
from pmdarima import auto_arima
from sklearn import metrics
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller
warnings.filterwarnings("ignore")

df = pd.read_excel(r'/content/Quarterly export current prices fisheries  products.xlsx', parse_dates = True)

def timeseries_evaluation_metrics_func(y_true, y_pred):
    def mean_absolute_percentage_error(y_true, y_pred):
        y_true, y_pred = np.array(y_true), np.array(y_pred)
        return np.mean(np.abs((y_true - y_pred) / y_true)) * 100
        y_true, y_pred = np.array(y_true), np.array(y_pred)
    mse = metrics.mean_squared_error(y_true, y_pred)
    mae = metrics.mean_absolute_error(y_true, y_pred)
    rmse = np.sqrt(mse)
    mape = mean_absolute_percentage_error(y_true, y_pred)
    r2 = metrics.r2_score(y_true, y_pred)


    print('Evaluation metric results:')
    print(f'MSE: {mse}')
    print(f'MAE: {mae}')
    print(f'RMSE: {rmse}')
    print(f'MAPE: {mape}')
    print(f'R2: {r2}')

def Augmented_Dickey_Fuller_Test_func(series, column_name):
    print(f'Results of Dickey-Fuller Test for column: {column_name}')
    dftest = adfuller(series, autolag='AIC')
    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic', 'p-value', 'No Lags Used', 'Number of Observations Used'])

    for key, value in dftest[4].items():
        dfoutput[f'Critical Value ({key})'] = value

    print(dfoutput)

    if dftest[1] <= 0.05:
        print("Conclusion:====>")
        print("Reject the null hypothesis")
        print("Data is stationary")
    else:
        print("Conclusion:====>")
        print("Fail to reject the null hypothesis")
        print("Data is non-stationary")

Augmented_Dickey_Fuller_Test_func(df['Fisheries'],'Fisheries')

#Train and test set
X = df[['Fisheries' ]]
train, test = X[0:-4], X[-4:]

#SARIMA
for m in [4]:
    print("="*100)
    print(f' Fitting SARIMA for Seasonal value m = {str(m)}')
    stepwise_model = auto_arima(train, start_p=1, start_q=1,
                               max_p=7, max_q=7, seasonal=True, start_P=1,
                               start_Q=1, max_P=7, max_D=7, max_Q=7, m=m,
                               d=None, D=None, trace=True, error_action='ignore', suppress_warnings=True,
                               stepwise=True)

print(f'Model summary for m = {str(m)}')
print("-"*100)
stepwise_model.summary()

#Evaluating Forecast Model
forecast ,conf_int= stepwise_model.predict(n_periods=4,return_conf_int=True)
df_conf = pd.DataFrame(conf_int,columns= ['Upper_bound','Lower_bound'])
df_conf["new_index"] = range(88, 92)
df_conf = df_conf.set_index("new_index")
forecast = pd.DataFrame(forecast,
columns=['close_pred'])
forecast["new_index"] = range(88, 92)
forecast = forecast.set_index("new_index")
timeseries_evaluation_metrics_func(test, forecast)

#Diagnostic Plot
get_ipython().run_line_magic('matplot')

display(stepwise_model.plot_diagnostics());

#Forecast
pred,conf_int = stepwise_model.predict(n_periods=11,return_conf_int=True)
pred = pd.DataFrame(pred,columns=['Fisheries'])
df_conf = pd.DataFrame(conf_int,columns= ['Lower_bound','Upper_bound'])
df_conf["new_index"] = range(90, 101)
df_conf = df_conf.set_index("new_index")
timeseries_evaluation_metrics_func(test, forecast)

pred["new_index"] = range(90, 101)
pred = pred.set_index("new_index")
pred

import matplotlib.pyplot as plt
get_ipython().run_line_magic('matplotlib', 'inline')
plt.rcParams["figure.figsize"] = [15, 7]
plt.plot(train, label='Train ')
plt.plot(test, label='Test ')
plt.plot(forecast, label='Predicted')
plt.plot(df_conf['Upper_bound'], label='Confidence IntervalUpper bound ')
plt.plot(df_conf['Lower_bound'], label='Confidence IntervalLower bound ')
plt.legend(loc='best')
plt.show()

